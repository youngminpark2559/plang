

# ================================================================================
# Iterator: object which you can extract values in turn

# ================================================================================
# You don't create 100 number of numbers
# But you create an iterator which you extract values from 0 to 99
# Data generation is delayed, which is called lazy evaluation
# for i in range(100):
#   print(i)

# ================================================================================
# Iterable object: 
# 1. Object which has __iter__()
# 2. string, list, dictionary, set, etc

# ================================================================================
num_list=[1,2,3]
.__iter__()
<list_iterator object at 0x03616630>
리스트의 이터레이터를 변수에 저장한 뒤 __next__ 메서드를 호출해보면 요소를 차례대로 꺼낼 수 있습니다.

>>> it = [1, 2, 3].__iter__()
>>> it.__next__()
1
>>> it.__next__()
2
>>> it.__next__()
3
>>> it.__next__()
Traceback (most recent call last):
  File "<pyshell#48>", line 1, in <module>
    it.__next__()
StopIteration

# 객체가 반복 가능한 객체인지 알아보는 방법은 객체안에 __iter__ 메서드가 들어있는지 확인해보면 됩니다. 
# 다음과 같이 dir 함수를 사용하면 객체의 메서드를 확인할 수 있습니다.
dir([1, 2, 3])
# ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', 
#  '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', 
#  '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', 
#  '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', 
#  '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 
#  'remove', 'reverse', 'sort']

# --------------------------------------------------
# 이 리스트에서 __iter__를 호출해보면 이터레이터를 얻을 수 있습니다.

[1, 2, 3].__iter__()
# <list_iterator object at 0x03616630>

# --------------------------------------------------
# 리스트의 이터레이터를 변수에 저장한 뒤 __next__ 메서드를 호출해보면 리스트 안의 요소를 차례대로 하나씩 꺼낼 수 있습니다.
it = [1, 2, 3].__iter__()
it.__next__()
# 1
it.__next__()
# 2
it.__next__()
# 3
it.__next__()
# Traceback (most recent call last):
#   File "<pyshell#48>", line 1, in <module>
#     it.__next__()
# StopIteration

# --------------------------------------------------
# 3 다음에 __next__를 호출하면 StopIteration 예외가 발생합니다. 
# 즉, [1, 2, 3]이므로 1, 2, 3 세 번 반복합니다.

# 이처럼 이터레이터는 __next__로 요소를 계속 꺼내다가 꺼낼 요소가 없으면 StopIteration 예외를 발생시켜서 반복을 끝냅니다.

# --------------------------------------------------
# 물론, 리스트뿐만 아니라 문자열, 딕셔너리, 세트도 __iter__를 호출하면 이터레이터 객체를 얻을 수 있습니다. 

# 그리고 이터레이터에서 __next__를 호출하면 차례대로 값을 꺼낼수 있습니다.

'Hello, world!'.__iter__()
# <str_iterator object at 0x03616770>

{'a': 1, 'b': 2}.__iter__()
# <dict_keyiterator object at 0x03870B10>

{1, 2, 3}.__iter__()
# <set_iterator object at 0x03878418>

# --------------------------------------------------
# 리스트, 문자열, 딕셔너리, 세트는 안에 저장된 요소가 눈에 보이는 반복 가능한 객체입니다. 

# 이번에는 안에 저장된 요소들이 눈에 보이지 않는 range를 살펴보겠습니다. 
# 다음과 같이 range(3)에서 __iter__로 이터레이터를 얻어낸 뒤 __next__ 메서드를 호출해봅니다.

it = range(3).__iter__()
it.__next__()
# 0
it.__next__()
# 1
it.__next__()
# 2
it.__next__()
# Traceback (most recent call last):
#   File "<pyshell#5>", line 1, in <module>
#     it.__next__()
# StopIteration

# ======================================================================
# 39.1.1  for와 반복 가능한 객체
# 이제 for에 반복 가능한 객체를 사용했을 때 동작 과정을 알아보겠습니다. 
# 다음과 같이 for에 range(3)을 사용했다면 
# 먼저 range에서 __iter__로 이터레이터를 얻습니다. 
# 그리고 한 번 반복할 때마다 이터레이터에서 __next__로 숫자를 꺼내서 i에 저장하고, 
# 지정된 숫자 3이 되면 StopIteration을 발생시켜서 반복을 끝냅니다.

# --------------------------------------------------
# 이처럼 반복 가능한 객체는 __iter__ 메서드를 호출해서 그 객체의 이터레이터 객체를 얻고, 
# 얻어진 이터레이터의 __next__ 메서드를 호출하여 반복합니다. 

# 여기서는 반복 가능한 객체(like list)와 이터레이터(iterator object of list)가 분리되어 있지만 
# 클래스에 __iter__와 __next__ 메서드를 모두 구현하면 이터레이터를 만들 수 있습니다. 

# 특히 __iter__, __next__를 가진 객체를 iterator protocol 을 지원한다고 말합니다.

# --------------------------------------------------
# 정리하자면 반복 가능한 객체는 요소를 한 번에 하나씩 가져올 수 있는 객체이고, 
# 이터레이터는 __next__ 메서드를 사용해서 차례대로 값을 꺼낼 수 있는 객체입니다. 

# 반복 가능한 객체(iterable)와 이터레이터(iterator)는 별개의 객체이므로 둘은 구분해야 합니다. 
# 즉, 반복 가능한 객체에서 __iter__ 메서드로 이터레이터를 얻습니다.

# ======================================================================
# 시퀀스 객체와 반복 가능한 객체의 차이
# 'Unit 11 시퀀스 자료형 활용하기'에서 리스트, 튜플, range, 문자열은 시퀀스 객체라고 했는데, 
# 이 유닛에서는 "리스트, 튜플, range, 문자열" 을 반복 가능한 객체라고 했습니다. 

# 시퀀스 객체와 반복 가능한 객체의 차이점은 무엇일까요?

# 다음 그림과 같이 반복 가능한 객체는 시퀀스 객체를 포함합니다.
반복 가능한 객체 > 시퀀스 객체

# --------------------------------------------------
# 리스트, 튜플, range, 문자열은 반복 가능한 객체이면서 시퀀스 객체입니다. 

# 하지만, 딕셔너리와 세트는 반복 가능한 객체이지만 시퀀스 객체는 아닙니다. 
# 왜냐하면 시퀀스 객체는 요소의 순서가 정해져 있고 연속적(sequence)으로 이어져 있어야 하는데, 
# 딕셔너리와 세트는 요소(키)의 순서가 정해져 있지 않기 때문입니다. 
# 따라서 시퀀스 객체가 반복 가능한 객체보다 좁은 개념입니다.

# 즉, 요소의 순서가 정해져 있고 연속적으로 이어져 있으면 시퀀스 객체, 요소의 순서와는 상관없이 요소를 한 번에 하나씩 꺼낼 수 있으면 반복 가능한 객체입니다.
